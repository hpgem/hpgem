== About code conventions ==

The code conventions can be found online at http://www.hpgem.org/development/coding-style-of-the-kernel
They are intended to make the code more uniform. Uniform code is more easy to read. If you ignore the coding conventions, you may find that you suddenly have to resolve some mayor text conflicts or even tree conflicts, because somebody decided to clean up.

== The classes Element and Face ==

The classes Element and Face are responsible for providing access to the basis functions. This potentially means applying a coordinate transformation, because it is easier to write integrands as if the integrals are computed on physical coordinates. Basis functions are typically used in the innermost loops of an application, where performance is the most critical. It is unfeasible to pre-compute transformed gradients for all quadrature points for all elements, due to memory limitations. To work around this limitation the pre-computation is delegated to a wrapper class. It is wrapped around the Element that is currently being integrated. This does not affect storage because this process does not affect the Element itself. However, the wrapper has to pretend it is the actual Element while it is presented to the user for use in computing the integrand. This means all functions present in Element should also be overridden in the wrapper. When you add a function to Element that has to be usable during integration, also add an override to the wrapper.

The same argument also holds for Face.

When a function of Element or Face behaves weird (typically by returning nullptr or 0 where it should not) this usually means someone decided this function is not needed during integration and/or forgot to override it. Feel free to do so yourself.

== About assertions ==

The intended use of assertions in general and logger.assert for hpGEM is to check blatant assumptions on the arguments provided to the functions. For example, if you are trying to request entry 12 of an array of size 4, this is clearly wrong and you should change your function. 

Assertions should be used freely, but checking everything, all the time, is expensive. Therefore assertions are compiled out of the code completely in Release configuration. However, this also means that if you accidentally do something that has side effects in an assertion, the behaviour of your code may change between configurations. For example, NEVER DO 'logger.assert(x=4, "/// WRONG!!");'

Preparing data for the assertions is also expensive. If you want to assert something that depends on data that is not yet computed and not needed elsewhere in the function, do NOT compute it before the assertion. Rather write a dedicated function checkThisCondition that return bool and call it inside the assertion. (make sure to think of a better name for the function!)

== About optimisation ==

Always assume compiler developers are better at optimising code than you are. They are hired specifically to optimise code. Moreover they don't have to worry about the readability of the code they produce and they can use tricks that are not available in non-compiled c++. Compiler developers have to make assumptions about the code they are going to process. These tend towards processing code that is easy to read and write. Because of this, if you break these assumptions, they will instead assume you know what you are doing and are after a specific effect. THIS MAY MEAN THAT WRITING CLEVER CODE BECAUSE YOU THINK IT IS FASTER PRODUCES WORST PERFORMANCE THAN A NAIVE IMPLEMENTATION!

That being said, there are things that can be done to make an application faster, you just have to be careful that they actually make the application faster.

Optimising code only makes sense if you are building in Release mode, before doing anything else, set CMAKE_BUILD_TYPE to Release and make sure hpGEM_ENFORCE_ASSERTIONS is OFF. All effort spend in other configurations is almost certainly wasted and probably even counterproductive. Make sure you have some timing information to compare before and after, to see if you made any improvements.

Before changing anything, you want to know where the bottlenecks are. To do this, use a profiler, such as gprof(linux) or Instruments(mac), on a representative application. With this information in hand either make sure the most expensive methods get called less often or try to improve the efficiency of this method. Note that saving information will most likely speed up your application, but comes at the cost of a larger memory footprint. This may mean large applications no longer run. This is NOT an ideal situation.

Between steps and after you are done, make sure to compare with your old timings. If things went worse, discard your changes and try again.

== About debugging ==

Debugging code only makes sense if you are building in Debug mode, before doing anything else, set CMAKE_BUILD_TYPE to Debug. If this changes the behaviour of your code, first toggle hpGEM_DISABLE_ASSERTIONS to see if someone made a mistake in an assertion. If this did not alter the behaviour you have to hope a combination of CMAKE_BUILD_TYPE=RelWithDebInfo and hpGEM_ENFORCE_ASSERTIONS provides enough useful information

If you feel it is necessary to see additional debug output, you can set the advanced CMake option hpGEM_LOGLEVEL to DEBUG. There is quite a lot of additional debug info, so you probably want to pipe your output into grep or a similar text search tool.

If PETSc is reporting errors this usually means something went wrong in the interaction between hpGEM and PETSc. In this case it may be useful to add the PETSc option -on_error_abort. This will make your code crash on the first PETSc error.

If you are working on a mac, entering 'env DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib' in lldb before typing 'process launch' will enable lldb to trace memory corruption (for linux, valgrind can do this)

If something unexpected happens in the kernel of hpGEM this likely has one of the four following causes:

=== Case 1: Nonsense arguments were passed to a function and therefore it returned nonsense ===

This happens for example when some function tries to request entry 12 of an array of size 4. This situation should be debugged by adding assertions until the function successfully detects the erroneous arguments. In the example this means adding the line 'logger.assert(entry < 4, "This array only has 4 entries")'. Your code will now crash when 12 is passed to the array, making it more easy to find the places where stuff actually went wrong. Other developers may have the same issue, please commit the extra assertions.

=== Case 2: Some fields in a class contain nonsense and therefore it produces nonsense ===

This happens for example when someone constructs a face with a weird element. This means you are detecting one of the other two causes in an unfortunate place. Check the other functions that interact with the erroneous field for the actual source of the error.

=== Case 3: All arguments and the state of the class are valid, but it still breaks ===

This happens because of a programming error. Add a unit-test that detects the current problem and change things in the kernel until all unit tests pass. Once they do please commit the bugfix.

=== Case 4: Everything is fine, but there is an assertion or a unit test that fails ===

Unit-tests and assertions are great for detecting something is wrong, but unfortunately it may also be the unit-test or the assertion itself that is wrong. Please be extra careful to make sure it is actually the unit-test or the assertion that is wrong and when in doubt ask. When you commit the fix, clearly state in you commit message that you changed assertions or unit-tests because they were broken.

== FAQ ==
Q: Your 'performance optimisations' made the test suite much slower
A: The test suite tries to test parts of hpGEM in isolation. This means it sometimes has to take some non-standard actions to create or manipulate data. It often also takes an action once for many different shapes/basisfunctions/etc. while a typical application takes this action many times for the same shapes/basisfunctions/etc.. This means performance considerations for the test suite are different from performance considerations for performance critical applications and improving speed for the latter may have adverse effect on the former.

Q: This bit of code seems like it is wasteful to me
A: Did you have a look at a profiler already? Did you read the section about performance optimisations already?