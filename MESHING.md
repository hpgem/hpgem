# Intermediate Mesh format

This describes the intermediate mesh format that is used to store the partitioned mesh. This intermediate format is generated by the Preprocessor and allows the kernel only to read in the relevant part of the mesh (reducing memory load).

## Mesh description

The mesh format is a line based, with mostly space separated numbers on each line. To describe the line we will use the following syntax elements
 1. For visial clarity each line describing the output is prepend with a # (not present in the output).
 2. Values between quotations marks are literals, e.g. "mesh"
 3. Variables are prepended by a dollar sign
 4. Curly braces are used to denote variable length lists, e.g. `{N integers: ni}`
 5. Rectangular brances `[]` are used to denote conditional entries, see the description for the specifics
 6. Round brackets `()` are used to denote conditionals. At the end of a line they denote that a line is conditional. At the start of a section they denote that the whole section is conditional.



### Header part:
```
# "mesh" $version
# $nnode $nelem $dim [$nface [$nedge]]
# $npart ($npart integers: $pni)
```
where

 1. `$version` interger version of the mesh file. Here we describe versions 1 and 2
 2. `$nnode` integer number of nodes in the mesh
 3. `$nelem` integer number of elements in the mesh
 4. `$dim` integer dimension of the mesh
 5. `$nface` and `$nedge` integer number of faces and edges in the file. Inclusion is dependent on the dimension. `$nface` requires dimension >= 2, `$nedge` requires dimension >= 3. The borders between elements in 2D will be denoted as faces (following convention).

### Zones
Elements are grouped into zones, for example based on their material properties.
```
(version >= 2)
# "zones"
# $nzone
$nzone lines:
  # $name
```
where

 1. `$nzone` is the integer number of zones
 2. `$name` is a string with the name of the zone, terminated by the end of the line.


### Nodes
```
# "nodes" (version >= 2)
$nnode grouped lines:
  # $npart {$npart integers $nparti}
  # $ncoord {$ncoord  $dim-tuples of floats $cxi}
```
where

 1. `$npart` integers `$nparti` are the indices of the partitions for which this node is relevant
 2. `$ncoord` is the number of coordinates which are associated with this node
 3. `$cxi` are the actual coordinates stored as hexadecimal floating point numbers.

Note that the sum of `$npart` will be larger than the number of nodes as nodes are seen as relevant when they either border an owned element or are in the ghost layer of that partition.

### Elements
```
# "elements"
$nelem grouped lines
  # $nenodes {$nenodes pairs of integers $ni, $ci} $nown $nghost {$nghost integers, $gi}
  # $zi (version >= 2)
```
where

 1. `$nenodes` is the number integer of nodes for the element. Together with the dimension this also determines the type of the node.
 2. `$ni` and `$ci` describe the nodes that are linked to the element. `$ni` is the global index of the node, for this element it corresponds to the `$ci`-th coordinate of that node.
 3. `$nown` the owning partition
 4. `$nghost` indices `$gi` are the partitions for which this element is in the ghost layer
 5. `$zi` The index of the zone to which this element belongs

### Faces
```
(dimension >= 2)
# "codim1" (version >= 2)
$nface lines:
  # $nfelem {$nfelem pairs of integers $nei, $neli} $nfpart {$nfpart integers: $npi}
```
where
 1. `$nfelem` the number of adjacent elements
 2. The pair `$nei` `$neli` means that it is connected to element `$nei` and on that element it the `$neli`-th face
 3. `$nfpart` indices `$npi` are the partitions which need to read this face 

### Edges
```
(dimension >= 3)
# "codim2" (version >= 2)
$nedge lines:
  # (same as for faces)
```
The lines describing the edges are identical in format to those describing faces.

## Design notes:

1. The format is designed so that each partition can easily decide whether to load an entity (Element, Face, Edge or Node) based on the local information.
2. The extension to version 2 adds some headers purely for reading clarity.
3. The additions of zones is such that it should be possible to convert a v2 mesh to a v1 mesh. Additionally, the ordering is to simplify reading in the references.


## (Old) Mesh files

Starting from revision 916 mesh generation has been extracted to a preprocessor. This is required because we don't have enough RAM available to store the full mesh on every processor for large parallel simulations. The preprocessor avoids this problem by running sequentially and it does not need all the extra memory to store FEM solutions. The output of the preprocessor is such that each process in the large simulation only has to read and store the elements that it requires. 

Documentation about acceptable inputs for the preprocessor can be found in the [README](https://github.com/hpgem/hpgem/blob/master/README.md) file in the project root directory. The rest of this section will describe the mesh files. For examples you can look in [tests/files](https://github.com/hpgem/hpgem/tree/master/tests/files), which contains input data in files containing the word source and corresponding output in similarly named files containing the word mesh.

The first line of the mesh files always is equal to mesh 1. The next line contains 3 integers denoting the total number of nodes n, the total number of elements e and the dimension d of the mesh. 
In files describing meshes of dimension 2 or higher this is followed by the number of faces f in the mesh and for files describing 3-dimensional meshes also the number of edges e in the mesh.
The third line contains an integer denoting the number of partitions p, followed by p integers denoting in order the number of nodes that will be attributed to that partition. Note that the sum of these local amounts of nodes will in general be larger than the total number of nodes, because at the boundaries of partitions nodes need to appear in multiple partitions. 
After this there will be two lines per node. The first of these contains an integer denoting the number of partitions that should read this node p_n followed by p_n integers denoting those partitions. The other line contains an integer denoting the number of coordinates this node is associated with c, followed by c d-tuples of floating point numbers. Generated files will have these numbers in hexadecimal format to prevent rounding errors, but if you need to tweak one of these files a little, any floating point format will work. Nodes are linked to more than one coordinate if they are positioned on the 'boundary' of a periodic domain.
After the information about the nodes there is one line per element containing an integer representing the number of nodes for that elements n_e followed by n_e pairs of integers representing the global index of the nodes and the internal index of the coordinate that should be active in this element respectively. It contains all information for one node before continuing to the next node. After this it contains an integer representing the partition that is responsible for computations on this element, followed by an integer representing the number of partitions this element appears in as a shadow element s, followed by s integers denoting those shadow partitions. The global index of a node according to this file is equal to the number of nodes that precede it in the listing of nodes.
For files of dimension 2 or higher the remainder of the file contains entities that are not elements or nodes, ordered such that all entities of a higher dimension are listed before entities with a lower dimension. There is one line per entity. It begins with an integer denoting the number of elements n_f adjacent to that entity. After this there are n_f pairs of integers denoting the global index of the element and the local index of the entity inside the element respectively. It contains all information for one element before continuing the the next element. After this it contains an integer representing the number of partitions p_e that this entity should appear in. The line end with p_e integers denoting those partitions. Not that a partition is only guaranteed to contain all adjacent elements if it is responsible for computations on at least one adjacent element.
